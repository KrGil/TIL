# 용어 정리

- CSS : cascading style sheet
  - cascading : 위에서 흐르는, 상속 또는 종속하는
    1. 스타일 우선순위
       1. 중요도 
       2. 적용범위
       3. 소스 순서
    2. 스타일 상속



- SOA : Service Oriented Archtecture

  - 통신
    - ESB : Enterprize Service Bus
  - SOA의 웹 서비스는 서비스 제공업체가 SaaS 애플리케이션으로 제공할 수 있습니다.

  

- SaaS : 서비스로서의 소프트웨어 

  - 형태 : 애플리케이션과 기본 IT 인프라 및 플랫폼을 사용자에게 제공하는 클라우드 컴퓨팅 형태

    

- SOAP : Simple Object Access Protocol
  - 정보교환을 목적으로하는 경량의 XML 기반 프로토콜
  - RPC의 한 종류
    - RPC : 원격 프로시저 호출(영어: remote procedure call, 리모트 프로시저 콜, RPC)은 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다. 다시 말해, 원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치-에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.
  - 홈페이지 : https://www.w3.org/TR/soap/
  - SOAP 설명 : https://j2enty.tistory.com/96

- polyglot : 폴리글랏
  - 여러가지 언어로 개발하는 것
  - 여러가지 프로그래밍 언어로 작성된 프로그램·스크립트
  - 필요에 따라 여러 언어를 자유롭게 활용하는 프로그래밍 방식
  - 요구사항, 시스템 성격에 맞는 프로그래밍 언어를 이용하여 개발하는 방식 ★
  - 근데 사실 PHP[[1\]](https://zetawiki.com/wiki/폴리글랏_polyglot#cite_note-1)만 해도 HTML[[2\]](https://zetawiki.com/wiki/폴리글랏_polyglot#cite_note-2), CSS, JavaScript는 기본 ;;
  - 한편 여러 종류의 [Persistence](https://zetawiki.com/wiki/Persistence)(DB, 스토리지)를 붙여 쓸 수 있다는 의미로 사용하는 경우도 있음
- WSDL : WebService Description Language
  - Web Service가 제공하는 서비스에 대한 정보를 기록하기 위한 XML 기반의 마크업 언어

- UUID

  - 네트워크 상에서 고유성이 보장되는 id를 만들기 위한 표준 규약.
  - 주로 분산 컴퓨팅 환경에서 사용되는 식별자.

  - 사용되는 상황

    - 안녕하세요, 이도원입니다. 

      UUID의 일반적인 목적은 고유한 식별자를 갖기 위함니다. UUID가 고유한 키를 생성하기 위한 유일한 방법이라기 보다는 고유한 키를 간단하게 생성해서 사용할 수 있기 떄문에 사용합니다. 물론 UUID 값 자체를 저장하기 위해 일밙거인 키보다 많은 용량의 스토리지 필요하기도 합니다. 

      그러나, 분산 환경이나 동시성이 중요시 되는 작업에서 다음과 같은 상황이 발생한다고 가정해 봅시다.

      \- DB에서 각 레코드들의 ID를 한곳에서 관리하려고 하지 않을 때

      \- 여러 구성 요소 및 서비스들이 고유하지 않은 식벽자를 독립적으로 생성할 가능성이 있을 때

      위와 같은 상황에서 고유한 키를 어떻게 처리해야 할지 결정해야 합니다. 물론, 하나의 데이터베이스만을 사용하는 경우라면 굳이 유니크한 키를 사용할 필요는 없습니다. 또는, 어떤 키가 레코드를 고유하게 만드는 속성(Email, 주민등록번호 등)이라고 하면 역시 UUID가 필요하지 않을 수 있습니다. 

      그러나, 여러 데이터베이스를 사용하는 경우나 분산된 환경에서 애플리케이션을 운영하는 경우에, 자동 증가된(또는 시퀀스 넘버) 컬럼으로 레코드를 구분하는 경우라면, 서로 다른 레코드에 대해서 같은 ID가 사용될 확률이 높습니다. 이럴 경우에는 자동 증가 컬럼 이외에 ID를 생성해 주는 로직이 필요하게 됩니다(예, USR-0001, USR-0001, ITEM-0002 ...). 이럴 결우 UUID가 조금은 쉽게 처리할 수 있는 방법이라고 생각됩니다. 모든 레코드이 고유한 ID를 위해서 Email와 같은 고유 컬럼을 가지고 있지 않기 때문에, 고유키 생성 로직을 사용하는 것과 UUID 사용하는 것 등을 고려해야 할 것 같습이다. 

      강의에서 사용된 예제에서는 데이터 레코드의 크기나 데이터의 구조를 보았을 때, UUID를 사용하지 않고도 충분히 설명할 수 있기는 하지만, 일반적인 상황을 고려하여 UUID를 사용하는 쪽으로 설명하였습니다. 참고하시기 바랍니다. 

      감사합니다.

  - 결론

    - 각 ms마다 pk값들이 중복될 수 있으니 중복될 위험이 거의 없는 uuid를 사용.

- RabbitMQ / ActiveMQ

- 서킷 브레이크 패턴
- 이벤트 큐
- 컨텍스트 매핑 패턴

- Builder 패턴

  - 빌더 패턴을 사용해야하는 이유 : https://mangkyu.tistory.com/163

  - 1. 필요한 데이터만 설정할 수 있음

    유연성을 확보할 수 있음

    가독성을 높일 수 있음

    불변성을 확보할 수 있음

- db indexing
  - query문 자체에 인덱싱 하는것.

- 