# [객체지향과 디자인패턴] 캡슐화(encapsulation)

> 요즘 출근길에 [개발자가 반드시 정복해야할 객체지향과 디자인패턴](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788969090010)을 읽고 있습니다. 아직 초반부를 읽는 중인데 책을 읽다 보니 캡슐화에 대해서 설명이 되어 있더군요. 곰곰히 생각해보니 저는 캡슐화에 대해서 상세하게 알고 있지 않은 상태였습니다! 캡슐화 == '메소드로 빼기' 정도로만 인지하고 있더군요. 그래서 책에 나와 있는 내용을 바탕으로 캡슐화에 대해 정리해 보았습니다.

# 캡슐화

객체 지향을 처음 접하는 사람들은 무심결에 데이터 중심적인 절차 지향 방식 습관으로 코드를 짜는 습관을 가지고 있습니다. 이러한 습관을 고치는데 도움이 되는 두 개의 규칙이 존재합니다.

## 캡슐화를 위한 두 개의 규칙

1. Tell, Don't Ask
2. 데미테르의 법칙(Law of Demeter)



### "Tell, Don't Ask"

"Tell, Don't Ask"는 데이터를 물어보지 않고 기능을 실행해 달라고 말하는 규칙입니다. 회원 만료 여부를 확인하는 코드로 예를 들어 보겠습니다.

```java
// member.getExpiryDate(): 만료 일자 데이터를 가져옴
if (member.getExpiryDate() != null && 
    member.getExpiryDate().getDate() < System.currentTimeMills()) {
    // 만료 되었을 때의 처리
}
```

데이터를 읽는 것은 데이터를 중심으로 코드를 작성하게 만드는 원인입니다. 따라서 데이터를 읽는 방식으로 코드를 작성하게 되면 절차 지향적인 코드를 유도하게 됩니다.



따라서 데이터 대신 기능을 실행해 달라고 명령을 내려야 합니다. 이 기능을 실행하기 위해 만료 일자 데이터를 가진 객체에게 만료 여부를 확인해 달라고 해야 합니다.

```java
if(member.isExpired()){
    // 만료에 따른 처리
}
```

위와 같이 기능 실행을 요청하는 방식으로 코드를 작성하다 보면, 자연스럽게 해당 기능을 어떻게 구현했는지 여부가 감춰집니다. 즉, 기능 구현이 캡슐화 되는 것입니다.



### 데이테르의 법칙(Law of Demeter)

데미테르의 법칙은 `Tell, Don't Ask` 규칙을 따를 수 있도록 만들어 주는 다른 규칙입니다. 

- 메서드에서 생성한 객체의 메서드만 호출
- 파라미터로 받은 객체의 메서드만 호출
- 필드로 참조하는 객체의 메서드만 호출

```java
public void processSome(Member member){
    if(member.getDate().getTime() < ...){ // 데미테르 법칙 위반
        ...
    }
}
```

위 코드는 데미테르법칙의 `파라미터로 받은 객체의 메서드만 호출`을 어긴 코드입니다. 

파라미터로 전달받은 member의 getDate() 메서드를 호출한 뒤, 다시 getDate()가 리턴한 Date 객체의 getTime() 메서드를 호출하기 때문입니다.

따라서 데미테르의 법칙을 따르려면, 위 코드를 member 객체에 대한 한 번의 메서드 호출(member.getSomeThing())으로 변경해 주어야 합니다. 















